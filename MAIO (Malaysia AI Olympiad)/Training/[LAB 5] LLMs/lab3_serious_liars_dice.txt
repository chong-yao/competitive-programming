{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "b2a12a2c-2c2c-4812-a51f-26a7c481718c",
   "metadata": {},
   "source": [
    "# Lab 5 Part 3 - Serious Liar's Dice"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c5f62640-98d9-441f-8271-3b051f3f3000",
   "metadata": {},
   "source": [
    "In Part 2, all AI players have the same prompt. If you wanted to compare between models, you could only compare between the Gemini family. Let's include more model providers in the mix."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bb16ffa5-e35b-4254-bc36-1d40671c20b4",
   "metadata": {},
   "source": [
    "Set up an API key from openrouter.ai. Create an account, and in Settings -> Privacy, toggle on `Enable providers that may train on inputs` under Paid Models and toggle on `Enable training and logging (chatroom and API)` under Free Models. This will allow you to use some models for free at a low rate in exchange of your chat data being used for model training. I believe that is acceptable for the purposes of this lab. In general however, please be wary about passing your own data to LLM providers.\n",
    "\n",
    "Next, paste the API keys in files called `googleapikey.txt` and `openrouterapikey.txt` in the same folder as this notebook. It should look like this:\n",
    "\n",
    "```\n",
    "# googleapikey.txt\n",
    "your-api-key-here\n",
    "\n",
    "# openrouterapikey.txt\n",
    "your-api-key-here\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3f4bd202-5002-4962-998e-45ffbbed0d5c",
   "metadata": {},
   "source": [
    "On top of the packages in the Telephone Game notebook, ensure `langchain-openai` is installed."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9ceec52f-0e46-4ed5-92c7-790d4fa7766e",
   "metadata": {},
   "source": [
    "Here is an example of how you can run free models from openrouter.ai."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "826521d2-7d93-4e38-9499-d028b7ab23d5",
   "metadata": {},
   "source": [
    "```python\n",
    "from langchain_openai import ChatOpenAI\n",
    "\n",
    "llama3_3 = ChatOpenAI(\n",
    "    base_url=\"https://openrouter.ai/api/v1\",\n",
    "    api_key=config(\"OPENROUTER_API_KEY\"),\n",
    "    model=\"meta-llama/llama-3.3-8b-instruct:free\",\n",
    ")\n",
    "\n",
    "chain = (\n",
    "    ChatPromptTemplate.from_template(\"Generate a limerick based on: {theme}\") | llama3_3 | StrOutputParser()\n",
    ")\n",
    "\n",
    "chain.invoke({\"theme\": \"bananas\"})\n",
    "# 'There once was a banana so bright,\\nGrew in the tropics with warm delight.\\nIt ripened with care,\\nAnd was eaten with flair,\\nAnd its taste was a pure pleasure in sight!'\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f412a52b-f168-4934-9baf-733c4b6cb29f",
   "metadata": {},
   "source": [
    "## Making a serious Liar's Dice game"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a3755074-b080-4c59-8827-81a9c2b6afb7",
   "metadata": {},
   "source": [
    "Go ahead and set up a Liar's Dice game where we pit free models against each other. Use the following:\n",
    "\n",
    "- \"meta-llama/llama-3.3-8b-instruct:free\"\n",
    "- \"google/gemma-3-12b-it:free\"\n",
    "- \"mistralai/mistral-small-3.1-24b-instruct:free\"\n",
    "- \"qwen/qwen3-8b:free\"\n",
    "\n",
    "Note that for qwen3 models, you need to use /nothink in the prompt to prevent it from going into reasoning mode, as it will spend too much of your free limit and will be very slow to return results. Example code:\n",
    "\n",
    "```python\n",
    "qwen3_8b = ChatOpenAI(\n",
    "    base_url=\"https://openrouter.ai/api/v1\",\n",
    "    api_key=config(\"OPENROUTER_API_KEY\"),\n",
    "    model=\"qwen/qwen3-8b:free\",\n",
    ")\n",
    "chain = (\n",
    "    ChatPromptTemplate.from_template(\"/nothink Generate a limerick based on: {theme}\")\n",
    "    | qwen3_8b | StrOutputParser()\n",
    ")\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "59428a9f",
   "metadata": {},
   "outputs": [],
   "source": [
    "import random\n",
    "import time\n",
    "import json\n",
    "from typing import Dict, List, Optional\n",
    "from collections import defaultdict\n",
    "from langchain_core.output_parsers import StrOutputParser\n",
    "from langchain_core.prompts import ChatPromptTemplate\n",
    "from langchain_google_genai import ChatGoogleGenerativeAI\n",
    "from langchain_openai import ChatOpenAI"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f8c41f13",
   "metadata": {},
   "outputs": [],
   "source": [
    "with open(\"googleapikey.txt\", \"r\") as f:\n",
    "    GOOGLE_API_KEY = f.read().strip()\n",
    "\n",
    "with open(\"openrouterapikey.txt\", \"r\") as f:\n",
    "    OPENROUTER_API_KEY = f.read().strip()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "82ead571",
   "metadata": {},
   "outputs": [],
   "source": [
    "from typing import List\n",
    "import time\n",
    "import random\n",
    "\n",
    "class LiarsDiceGame:\n",
    "    def __init__(self):\n",
    "        self.players = {}\n",
    "        self.current_bid = None\n",
    "        self.history = []\n",
    "        self.turn_order = []\n",
    "        self.current_turn = 0\n",
    "        self.round_count = 0\n",
    "        \n",
    "    def setup_game(self, ai_players: List, dice_per_player: int = 5):\n",
    "        \"\"\"Set up the Liar's Dice game\"\"\"\n",
    "        player_names = [i.name for i in ai_players]\n",
    "        self.turn_order = player_names\n",
    "        self.total_dice = len(player_names) * dice_per_player\n",
    "        \n",
    "        for name, ai_player in zip(player_names, ai_players):\n",
    "            self.players[name] = {\n",
    "                'dice': [random.randint(1, 6) for _ in range(dice_per_player)],\n",
    "                'num_dice': dice_per_player,\n",
    "                'ai_player': ai_player\n",
    "            }\n",
    "        \n",
    "        print(\"LIAR'S DICE!\")\n",
    "        print(f\"Players: {', '.join(player_names)}\")\n",
    "        print(f\"Total dice: {self.total_dice}\")\n",
    "        \n",
    "        print(\"\\nDICE (not visible to players):\")\n",
    "        for name, data in self.players.items():\n",
    "            print(f\"{name}: {data['dice']}\")\n",
    "\n",
    "    def display_game_state(self):\n",
    "        \"\"\"Display current game state\"\"\"\n",
    "        print(f\"\\n{'='*60}\")\n",
    "        print(f\"ROUND {self.round_count + 1} - GAME STATE\")\n",
    "        print('='*60)\n",
    "        \n",
    "        print(\"PLAYERS:\")\n",
    "        for name in self.turn_order:\n",
    "            data = self.players[name]\n",
    "            dice_display = f\"{data['dice']} ({data['num_dice']} dice)\"\n",
    "            current_marker = \" ← CURRENT TURN\" if name == self.turn_order[self.current_turn] else \"\"\n",
    "            print(f\"   {name}: {dice_display}{current_marker}\")\n",
    "        \n",
    "        if self.current_bid:\n",
    "            print(f\"\\nCURRENT BID: {self.current_bid['quantity']} dice show {self.current_bid['face_value']} (by {self.current_bid['player']})\")\n",
    "        else:\n",
    "            print(\"\\nCURRENT BID: None (round start)\")\n",
    "        \n",
    "        print(f\"\\n📊 TOTAL DICE IN PLAY: {self.total_dice}\")\n",
    "        \n",
    "        if self.history:\n",
    "            print(f\"\\n📜 RECENT HISTORY:\")\n",
    "            for action in self.history[-5:]:  # Show last 5 actions\n",
    "                print(f\"   • {action}\")\n",
    "    \n",
    "    def is_valid_bid(self, quantity: int, face_value: int) -> bool:\n",
    "        \"\"\"Check if bid is higher than current bid\"\"\"\n",
    "        if not self.current_bid:\n",
    "            return quantity > 0 and 1 <= face_value <= 6\n",
    "        \n",
    "        current_q = self.current_bid['quantity']\n",
    "        current_f = self.current_bid['face_value']\n",
    "        \n",
    "        return quantity > current_q or (quantity == current_q and face_value > current_f)\n",
    "    \n",
    "    def count_dice(self, face_value: int) -> int:\n",
    "        \"\"\"Count dice showing face_value (1s are wild)\"\"\"\n",
    "        total = 0\n",
    "        for player_data in self.players.values():\n",
    "            for die in player_data['dice']:\n",
    "                if die == face_value or die == 1:\n",
    "                    total += 1\n",
    "        return total\n",
    "    \n",
    "    def play_turn(self) -> bool:\n",
    "        \"\"\"Play one turn with enhanced display - returns False if game ends\"\"\"\n",
    "        self.display_game_state()\n",
    "        \n",
    "        current_player = self.turn_order[self.current_turn]\n",
    "        player_data = self.players[current_player]\n",
    "        \n",
    "        print(f\"\\n{current_player}'s turn\")\n",
    "        \n",
    "        # Get AI decision with full context\n",
    "        decision = player_data['ai_player'].make_decision(\n",
    "            player_data['dice'],\n",
    "            self.total_dice,\n",
    "            self.current_bid,\n",
    "            self.history,\n",
    "        )\n",
    "        \n",
    "        if decision[\"action\"] == \"bid\":\n",
    "            quantity = decision[\"quantity\"]\n",
    "            face_value = decision[\"face_value\"]\n",
    "            \n",
    "            if self.is_valid_bid(quantity, face_value):\n",
    "                self.current_bid = {\n",
    "                    'player': current_player,\n",
    "                    'quantity': quantity,\n",
    "                    'face_value': face_value\n",
    "                }\n",
    "                action_text = f\"{current_player} bids {quantity} dice show {face_value}\"\n",
    "                print(f\"✅ {action_text}\")\n",
    "                self.history.append(action_text)\n",
    "            else:\n",
    "                print(f\"❌ Invalid bid from {current_player}! Auto-correcting...\")\n",
    "                # Force a valid bid\n",
    "                if self.current_bid:\n",
    "                    if self.current_bid['face_value'] < 6:\n",
    "                        quantity = self.current_bid['quantity']\n",
    "                        face_value = self.current_bid['face_value'] + 1\n",
    "                    else:\n",
    "                        quantity = self.current_bid['quantity'] + 1\n",
    "                        face_value = 2\n",
    "                else:\n",
    "                    quantity, face_value = 1, 2\n",
    "                \n",
    "                self.current_bid = {\n",
    "                    'player': current_player,\n",
    "                    'quantity': quantity,\n",
    "                    'face_value': face_value\n",
    "                }\n",
    "                action_text = f\"{current_player} bids {quantity} dice show {face_value} (auto-corrected)\"\n",
    "                print(f\"🔧 {action_text}\")\n",
    "                self.history.append(action_text)\n",
    "                \n",
    "        elif decision[\"action\"] == \"challenge\":\n",
    "            if not self.current_bid:\n",
    "                print(\"❌ Can't challenge - no bid to challenge!\")\n",
    "                return True  # Continue game\n",
    "            \n",
    "            action_text = f\"{current_player} challenges {self.current_bid['player']}'s bid\"\n",
    "            self.history.append(action_text)\n",
    "            return self.resolve_challenge(current_player)\n",
    "        \n",
    "        # Next player\n",
    "        self.current_turn = (self.current_turn + 1) % len(self.turn_order)\n",
    "        return True\n",
    "    \n",
    "    def resolve_challenge(self, challenger: str) -> bool:\n",
    "        \"\"\"Resolve challenge with detailed analysis - returns True if game ends\"\"\"\n",
    "        bid = self.current_bid\n",
    "        actual_count = self.count_dice(bid['face_value'])\n",
    "        \n",
    "        print(f\"\\n{'🚨 CHALLENGE RESOLUTION 🚨':^60}\")\n",
    "        print(f\"{challenger} challenges {bid['player']}'s bid:\")\n",
    "        print(f\"BID: {bid['quantity']} dice show {bid['face_value']}\")\n",
    "        \n",
    "        # Detailed count analysis\n",
    "        print(f\"\\nCOUNTING DICE SHOWING {bid['face_value']}:\")\n",
    "        for name, data in self.players.items():\n",
    "            player_count = sum(1 for die in data['dice'] if die == bid['face_value'] or die == 1)\n",
    "            ones = data['dice'].count(1)\n",
    "            targets = data['dice'].count(bid['face_value'])\n",
    "            print(f\"   {name}: {targets} natural {bid['face_value']}s + {ones} wilds = {player_count} total\")\n",
    "        \n",
    "        print(f\"\\nFINAL COUNT: {actual_count} dice show {bid['face_value']}\")\n",
    "        print(f\"BID CLAIMED: {bid['quantity']} dice show {bid['face_value']}\")\n",
    "        \n",
    "        if actual_count >= bid['quantity']:\n",
    "            print(f\"✅ BID WAS TRUE! {challenger} loses a die!\")\n",
    "            loser = challenger\n",
    "            winner = bid['player']\n",
    "        else:\n",
    "            print(f\"❌ BID WAS FALSE! {bid['player']} loses a die!\")\n",
    "            loser = bid['player']\n",
    "            winner = challenger\n",
    "        \n",
    "        # Remove die from loser\n",
    "        self.players[loser]['num_dice'] -= 1\n",
    "        if self.players[loser]['dice']:\n",
    "            self.players[loser]['dice'].pop()\n",
    "        \n",
    "        print(f\"{winner} wins the challenge!\")\n",
    "        print(f\"{loser} now has {self.players[loser]['num_dice']} dice\")\n",
    "        \n",
    "        result_text = f\"Challenge: {challenger} vs {bid['player']} - {winner} wins\"\n",
    "        self.history.append(result_text)\n",
    "        \n",
    "        # Check elimination\n",
    "        if self.players[loser]['num_dice'] == 0:\n",
    "            print(f\"{loser} is eliminated! 💀\")\n",
    "            self.turn_order.remove(loser)\n",
    "            if len(self.turn_order) == 1:\n",
    "                print(f\"\\n🎉 {self.turn_order[0]} WINS THE GAME! 🎉\")\n",
    "                return False\n",
    "        \n",
    "       # Re-roll ALL dice for new round and reset game state\n",
    "        print(f\"\\nRolling new dice for next round...\")\n",
    "        for name, data in self.players.items():\n",
    "            if data['num_dice'] > 0:  # Only re-roll for active players\n",
    "                data['dice'] = [random.randint(1, 6) for _ in range(data['num_dice'])]\n",
    "                print(f\"   {name}: {data['dice']}\")\n",
    "        \n",
    "        # Reset for next round\n",
    "        self.current_bid = None\n",
    "        self.current_turn = self.turn_order.index(winner)\n",
    "        self.total_dice = sum(p['num_dice'] for p in self.players.values())\n",
    "        self.round_count += 1\n",
    "        \n",
    "        print(f\"\\nNEW ROUND {self.round_count + 1}! {winner} starts with fresh dice\")\n",
    "        return True  # Continue game with new round"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5d1fc386-64ee-4a0d-bb3c-6a7c4451c8a6",
   "metadata": {},
   "source": [
    "## EX: Measuring LLM capability"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7188ff97-b40c-44bf-ac51-e5776cc6c034",
   "metadata": {},
   "source": [
    "How does each LLM measure up to each other when it comes to playing Liar's Dice? Track the necessary stats over multiple rounds of play and give your analysis based on that data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d990bdd9",
   "metadata": {},
   "outputs": [],
   "source": [
    "class AIPlayer:\n",
    "    def __init__(self, name: str, llm, is_qwen=False):\n",
    "        self.name = name\n",
    "        self.llm = llm\n",
    "        self.is_qwen = is_qwen\n",
    "        self.wins = 0\n",
    "        self.losses = 0\n",
    "        self.challenges_made = 0\n",
    "        self.challenges_won = 0\n",
    "        self.bids_made = 0\n",
    "        self.bids_successful = 0\n",
    "\n",
    "        # Thinking prompt\n",
    "        self.thinking_prompt = ChatPromptTemplate.from_template(\n",
    "            \"\"\"You are {player_name} playing Liar's Dice. Analyze the game state:\n",
    "\n",
    "GAME RULES:\n",
    "- 1s are WILD and count as any face\n",
    "- Bid format: <quantity> dice show <face_value>\n",
    "- New bids must be higher: increase quantity OR same quantity with higher face\n",
    "- Challenge if you doubt the bid\n",
    "\n",
    "CURRENT STATE:\n",
    "Your dice: {my_dice}\n",
    "Total dice: {total_dice}\n",
    "Current bid: {current_bid_str}\n",
    "Recent history:\n",
    "{history_str}\n",
    "\n",
    "THINKING:\n",
    "1. Analyze your hand (remember 1s are wild)\n",
    "2. Consider bid likelihood using total dice\n",
    "3. Evaluate risks of bidding vs challenging\n",
    "4. Strategy considerations\"\"\"\n",
    "        )\n",
    "\n",
    "        # Decision prompt - add /nothink prefix for Qwen models\n",
    "        decision_template = \"\" if not is_qwen else \"/nothink \"\n",
    "        decision_template += \"\"\"As {player_name} in Liar's Dice, DECIDE:\n",
    "\n",
    "CURRENT STATE:\n",
    "- Your dice: {my_dice}\n",
    "- Total dice: {total_dice}\n",
    "- Current bid: {current_bid_str}\n",
    "- Recent: {history_str}\n",
    "\n",
    "OPTIONS:\n",
    "{options}\n",
    "\n",
    "RULES:\n",
    "- Must bid if no current bid\n",
    "- New bid must be higher\n",
    "- Face must be 2-6 (1s are wild, not biddable)\n",
    "- Output EXACTLY one of:\n",
    "  • \"CHALLENGE\"\n",
    "  • \"BID <quantity> <face_value>\" (e.g., \"BID 3 4\")\n",
    "\n",
    "DECISION:\"\"\"\n",
    "        \n",
    "        self.decision_prompt = ChatPromptTemplate.from_template(decision_template)\n",
    "        self.thinking_chain = self.thinking_prompt | self.llm | StrOutputParser()\n",
    "        self.decision_chain = self.decision_prompt | self.llm | StrOutputParser()\n",
    "\n",
    "    def make_decision(\n",
    "        self,\n",
    "        my_dice: List[int],\n",
    "        total_dice: int,\n",
    "        current_bid: Optional[Dict],\n",
    "        game_history: List[str],\n",
    "    ) -> Dict:\n",
    "        current_bid_str = (\n",
    "            \"None (you start this round)\"\n",
    "            if not current_bid\n",
    "            else f\"{current_bid['quantity']} dice show {current_bid['face_value']} (by {current_bid['player']})\"\n",
    "        )\n",
    "        history_str = \"\\n\".join(f\"- {h}\" for h in game_history[-5:]) if game_history else \"None\"\n",
    "        \n",
    "        # Generate options based on game state\n",
    "        if current_bid:\n",
    "            options = (\n",
    "                f\"- CHALLENGE: If you doubt there are at least {current_bid['quantity']} of face {current_bid['face_value']}\\n\"\n",
    "                f\"- BID: Must be higher than current bid ({current_bid['quantity']}, {current_bid['face_value']})\"\n",
    "            )\n",
    "        else:\n",
    "            options = \"- BID: You must open the bidding (face 2-6)\"\n",
    "\n",
    "        try:\n",
    "            # Skip thinking for Qwen to save tokens\n",
    "            if not self.is_qwen:\n",
    "                thought = self.thinking_chain.invoke({\n",
    "                    \"player_name\": self.name,\n",
    "                    \"my_dice\": my_dice,\n",
    "                    \"total_dice\": total_dice,\n",
    "                    \"current_bid_str\": current_bid_str,\n",
    "                    \"history_str\": history_str\n",
    "                })\n",
    "                print(f\"💭 {self.name}'s thoughts:\\n   {thought.replace('\\n', '\\n   ')}\")\n",
    "            \n",
    "            # Get decision\n",
    "            decision = self.decision_chain.invoke({\n",
    "                \"player_name\": self.name,\n",
    "                \"my_dice\": my_dice,\n",
    "                \"total_dice\": total_dice,\n",
    "                \"current_bid_str\": current_bid_str,\n",
    "                \"history_str\": history_str,\n",
    "                \"options\": options\n",
    "            })\n",
    "            print(f\"🤖 {self.name} decides: {decision}\")\n",
    "            \n",
    "            return self._parse_decision(decision)\n",
    "\n",
    "        except Exception as e:\n",
    "            print(f\"❌ Error for {self.name}: {e}\")\n",
    "            return self._fallback_decision(current_bid)\n",
    "\n",
    "    def _parse_decision(self, response: str) -> Dict:\n",
    "        clean_res = response.strip().upper()\n",
    "        \n",
    "        # Handle challenge\n",
    "        if \"CHALLENGE\" in clean_res:\n",
    "            return {\"action\": \"challenge\"}\n",
    "        \n",
    "        # Handle bid\n",
    "        if clean_res.startswith(\"BID\"):\n",
    "            parts = clean_res.split()\n",
    "            if len(parts) < 3:\n",
    "                raise ValueError(\"Invalid bid format - missing values\")\n",
    "                \n",
    "            try:\n",
    "                quantity = int(parts[1])\n",
    "                face_value = int(parts[2])\n",
    "                if face_value < 2 or face_value > 6:\n",
    "                    raise ValueError(\"Face value must be 2-6\")\n",
    "                return {\"action\": \"bid\", \"quantity\": quantity, \"face_value\": face_value}\n",
    "            except (ValueError, IndexError):\n",
    "                raise ValueError(\"Invalid bid numbers\")\n",
    "        \n",
    "        raise ValueError(\"Unrecognized decision format\")\n",
    "\n",
    "    def _fallback_decision(self, current_bid: Optional[Dict]) -> Dict:\n",
    "        if not current_bid:\n",
    "            return {\n",
    "                \"action\": \"bid\",\n",
    "                \"quantity\": random.randint(1, 2),\n",
    "                \"face_value\": random.randint(2, 6),\n",
    "            }\n",
    "            \n",
    "        challenge_prob = min(0.6, current_bid[\"quantity\"] / 10.0)\n",
    "        if random.random() < challenge_prob:\n",
    "            return {\"action\": \"challenge\"}\n",
    "        elif current_bid[\"face_value\"] < 6:\n",
    "            return {\n",
    "                \"action\": \"bid\",\n",
    "                \"quantity\": current_bid[\"quantity\"],\n",
    "                \"face_value\": current_bid[\"face_value\"] + 1,\n",
    "            }\n",
    "        else:\n",
    "            return {\n",
    "                \"action\": \"bid\",\n",
    "                \"quantity\": current_bid[\"quantity\"] + 1,\n",
    "                \"face_value\": 2,\n",
    "            }\n",
    "            \n",
    "    def record_challenge(self, made: bool, won: bool):\n",
    "        if made:\n",
    "            self.challenges_made += 1\n",
    "            if won:\n",
    "                self.challenges_won += 1\n",
    "                \n",
    "    def record_bid(self, successful: bool):\n",
    "        self.bids_made += 1\n",
    "        if successful:\n",
    "            self.bids_successful += 1\n",
    "            \n",
    "    def record_result(self, won: bool):\n",
    "        if won:\n",
    "            self.wins += 1\n",
    "        else:\n",
    "            self.losses += 1\n",
    "            \n",
    "    def stats(self):\n",
    "        return {\n",
    "            \"wins\": self.wins,\n",
    "            \"losses\": self.losses,\n",
    "            \"win_rate\": self.wins / (self.wins + self.losses) if self.wins + self.losses > 0 else 0,\n",
    "            \"challenges_made\": self.challenges_made,\n",
    "            \"challenges_won\": self.challenges_won,\n",
    "            \"challenge_success_rate\": self.challenges_won / self.challenges_made if self.challenges_made > 0 else 0,\n",
    "            \"bids_made\": self.bids_made,\n",
    "            \"bids_successful\": self.bids_successful,\n",
    "            \"bid_success_rate\": self.bids_successful / self.bids_made if self.bids_made > 0 else 0\n",
    "        }"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2885fa72",
   "metadata": {},
   "outputs": [],
   "source": [
    "llama3_8b = ChatOpenAI(\n",
    "    base_url=\"https://openrouter.ai/api/v1\",\n",
    "    api_key=OPENROUTER_API_KEY,\n",
    "    model=\"meta-llama/llama-3.3-8b-instruct:free\",\n",
    ")\n",
    "\n",
    "gemma_12b = ChatOpenAI(\n",
    "    base_url=\"https://openrouter.ai/api/v1\",\n",
    "    api_key=OPENROUTER_API_KEY,\n",
    "    model=\"google/gemma-3-12b-it:free\",\n",
    ")\n",
    "\n",
    "mistral_24b = ChatOpenAI(\n",
    "    base_url=\"https://openrouter.ai/api/v1\",\n",
    "    api_key=OPENROUTER_API_KEY,\n",
    "    model=\"mistralai/mistral-small-3.1-24b-instruct:free\",\n",
    ")\n",
    "\n",
    "mistral_7b_instruct = ChatOpenAI(\n",
    "    base_url=\"https://openrouter.ai/api/v1\",\n",
    "    api_key=OPENROUTER_API_KEY,\n",
    "    model=\"mistralai/mistral-7b-instruct-v0.2:free\",\n",
    ")\n",
    "\n",
    "qwen_8b = ChatOpenAI(\n",
    "    base_url=\"https://openrouter.ai/api/v1\",\n",
    "    api_key=OPENROUTER_API_KEY,\n",
    "    model=\"qwen/qwen3-8b:free\",\n",
    ")\n",
    "\n",
    "players = [\n",
    "    AIPlayer(\"Llama3-8B\", llama3_8b),\n",
    "    AIPlayer(\"Gemma-12B\", gemma_12b),\n",
    "    AIPlayer(\"Mistral-24B\", mistral_24b),\n",
    "    AIPlayer(\"Qwen-8B\", qwen_8b)\n",
    "]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ece9cba0",
   "metadata": {},
   "outputs": [],
   "source": [
    "stats = {player.name: defaultdict(int) for player in players}\n",
    "num_games = 24  # Number of games to play\n",
    "dice_per_player = 5 # Fewer dice for faster games with 4 players\n",
    "\n",
    "# Run multiple games\n",
    "for game_num in range(num_games):\n",
    "    print(f\"\\n{'='*60}\")\n",
    "    print(f\"STARTING GAME {game_num+1}/{num_games}\")\n",
    "    print(f\"{'='*60}\")\n",
    "    \n",
    "    game = LiarsDiceGame()\n",
    "    game.setup_game(players, dice_per_player=dice_per_player)\n",
    "    \n",
    "    # Play game\n",
    "    turn_count = 0\n",
    "    max_turns = float(\"inf\")\n",
    "    game_ended = False\n",
    "    \n",
    "    while turn_count < max_turns and not game_ended:\n",
    "        print(f\"\\n{'--- TURN ' + str(turn_count + 1) + ' ---':^60}\")\n",
    "        \n",
    "        # Play turn and check if game ended\n",
    "        game_ended = not game.play_turn()\n",
    "        if game_ended:\n",
    "            # Game ended normally with a winner\n",
    "            winner_name = game.turn_order[0]  # Get winner from turn order\n",
    "            print(f\"\\n🎉 {winner_name} WINS THE GAME! 🎉\")\n",
    "            \n",
    "            # Record results for all players\n",
    "            for player in players:\n",
    "                player.record_result(player.name == winner_name)\n",
    "            \n",
    "            break  # Exit game loop\n",
    "            \n",
    "        turn_count += 1\n",
    "        #time.sleep(1)  # Shorter pause for faster games\n",
    "    \n",
    "    if turn_count >= max_turns:\n",
    "        print(\"\\nGame ended due to turn limit (draw)\")\n",
    "        # For draws, no one wins - just move to next game\n",
    "    \n",
    "    print(f\"\\nGame finished after {turn_count} turns!\")\n",
    "    \n",
    "    # Record results\n",
    "    winner = next(iter(game.players))  # Winner is the only remaining player\n",
    "    for player in players:\n",
    "        player.record_result(player.name == winner)\n",
    "        \n",
    "    # Print interim stats\n",
    "    print(\"\\nCURRENT STANDINGS:\")\n",
    "    for player in players:\n",
    "        print(f\"{player.name}: {player.wins} wins\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "66114084",
   "metadata": {},
   "outputs": [],
   "source": [
    "print(\"\\n\" + \"=\"*60)\n",
    "print(\"FINAL STATISTICS\")\n",
    "print(\"=\"*60)\n",
    "\n",
    "for player in players:\n",
    "    stats = player.stats()\n",
    "    print(f\"\\n{player.name} Performance:\")\n",
    "    print(f\"  Win Rate: {stats['win_rate']:.1%} ({stats['wins']}/{stats['wins']+stats['losses']})\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1b70cb5a",
   "metadata": {},
   "outputs": [],
   "source": [
    "llama3_8b = ChatOpenAI(\n",
    "    base_url=\"https://openrouter.ai/api/v1\",\n",
    "    api_key=OPENROUTER_API_KEY,\n",
    "    model=\"meta-llama/llama-3.3-8b-instruct\",\n",
    ")\n",
    "\n",
    "gemma_12b = ChatOpenAI(\n",
    "    base_url=\"https://openrouter.ai/api/v1\",\n",
    "    api_key=OPENROUTER_API_KEY,\n",
    "    model=\"google/gemma-3-12b-it\",\n",
    ")\n",
    "\n",
    "mistral_24b = ChatOpenAI(\n",
    "    base_url=\"https://openrouter.ai/api/v1\",\n",
    "    api_key=OPENROUTER_API_KEY,\n",
    "    model=\"mistralai/mistral-small-3.1-24b-instruct\",\n",
    ")\n",
    "\n",
    "mistral_7b_instruct = ChatOpenAI(\n",
    "    base_url=\"https://openrouter.ai/api/v1\",\n",
    "    api_key=OPENROUTER_API_KEY,\n",
    "    model=\"mistralai/mistral-7b-instruct-v0.2\",\n",
    ")\n",
    "\n",
    "qwen_8b = ChatOpenAI(\n",
    "    base_url=\"https://openrouter.ai/api/v1\",\n",
    "    api_key=OPENROUTER_API_KEY,\n",
    "    model=\"qwen/qwen3-8b\",\n",
    ")\n",
    "\n",
    "players = [\n",
    "    AIPlayer(\"Llama3-8B\", llama3_8b),\n",
    "    AIPlayer(\"Gemma-12B\", gemma_12b),\n",
    "    AIPlayer(\"Mistral-24B\", mistral_24b),\n",
    "    AIPlayer(\"Qwen-8B\", qwen_8b, is_qwen=True)\n",
    "]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b0f09dd6",
   "metadata": {},
   "outputs": [],
   "source": [
    "stats = {player.name: defaultdict(int) for player in players}\n",
    "num_games = 24  # Number of games to play\n",
    "dice_per_player = 5  # Fewer dice for faster games with 4 players\n",
    "\n",
    "# Run multiple games\n",
    "for game_num in range(num_games):\n",
    "    print(f\"\\n{'='*60}\")\n",
    "    print(f\"STARTING GAME {game_num+1}/{num_games}\")\n",
    "    print(f\"{'='*60}\")\n",
    "    \n",
    "    game = LiarsDiceGame()\n",
    "    game.setup_game(players, dice_per_player=dice_per_player)\n",
    "    \n",
    "    # Play game\n",
    "    turn_count = 0\n",
    "    max_turns = float(\"inf\")\n",
    "    game_ended = False\n",
    "    \n",
    "    while turn_count < max_turns and not game_ended:\n",
    "        print(f\"\\n{'--- TURN ' + str(turn_count + 1) + ' ---':^60}\")\n",
    "        \n",
    "        # Play turn and check if game ended\n",
    "        game_ended = not game.play_turn()\n",
    "        if game_ended:\n",
    "            # Game ended normally with a winner\n",
    "            winner_name = game.turn_order[0]  # Get winner from turn order\n",
    "            print(f\"\\n🎉 {winner_name} WINS THE GAME! 🎉\")\n",
    "            \n",
    "            # Record results for all players\n",
    "            for player in players:\n",
    "                player.record_result(player.name == winner_name)\n",
    "            \n",
    "            break  # Exit game loop\n",
    "            \n",
    "        turn_count += 1\n",
    "        #time.sleep(1)  # Shorter pause for faster games\n",
    "    \n",
    "    if turn_count >= max_turns:\n",
    "        print(\"\\nGame ended due to turn limit (draw)\")\n",
    "        # For draws, no one wins - just move to next game\n",
    "    \n",
    "    print(f\"\\nGame finished after {turn_count} turns!\")\n",
    "    \n",
    "    # Record results\n",
    "    winner = next(iter(game.players))  # Winner is the only remaining player\n",
    "    for player in players:\n",
    "        player.record_result(player.name == winner)\n",
    "        \n",
    "    # Print interim stats\n",
    "    print(\"\\nCURRENT STANDINGS:\")\n",
    "    for player in players:\n",
    "        print(f\"{player.name}: {player.wins} wins\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "751dffb6",
   "metadata": {},
   "outputs": [],
   "source": [
    "print(\"\\n\" + \"=\"*60)\n",
    "print(\"FINAL STATISTICS\")\n",
    "print(\"=\"*60)\n",
    "\n",
    "for player in players:\n",
    "    stats = player.stats()\n",
    "    print(f\"\\n{player.name} Performance:\")\n",
    "    print(f\"  Win Rate: {stats['win_rate']:.1%} ({stats['wins']}/{stats['wins']+stats['losses']})\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
